{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation Football La f\u00e9d\u00e9ration Fran\u00e7aise de Football souhaite refaire son site internet permettant la visualisation des matchs ainsi que leur gestion depuis un panel administrateur. Un script de cr\u00e9ation d\u2019une base de donn\u00e9es et insertion de donn\u00e9es a \u00e9t\u00e9 fourni pour la r\u00e9alisation. Ce qui a amen\u00e9 \u00e0 des modifications du sch\u00e9ma conceptuel de base pour qu\u2019il puisse r\u00e9pondre \u00e0 la demande exprim\u00e9e. La demande attendue est de pouvoir g\u00e9n\u00e9rer automatiquement les matchs pour un championnat en fonction du r\u00e9sultat de la pr\u00e9c\u00e9dente saison. Il faut \u00e9galement pouvoir modifier les scores des matchs tout en affectant le classement de la saison. Architecture L'architecture se base sur un serveur Apache et d'une base de donn\u00e9es Postgres. Cas d'utilisation Ce diagramme pr\u00e9sente les fonctionnalit\u00e9s disponibles sur l'application graph TB intialiseC(intialise un championnat) intialiseR(intialise les rencontres) connection(Se connecter) connectionAdmin(Se connecter en tant qu'admin) commente(commente un article) serveurBdd[(Serveur de base de donn\u00e9es)] Admin:::user --> connectionAdmin classDef user fill:#0acf00; Utilisateur:::user --> connection classDef user fill:#3355ff; connectionAdmin -- <<extend>> --> intialiseC connectionAdmin -- <<extend>> --> intialiseR connection -- <<extends>> --> commente serveurBdd <--> intialise Schema base de donn\u00e9es","title":"Home"},{"location":"#documentation-football","text":"La f\u00e9d\u00e9ration Fran\u00e7aise de Football souhaite refaire son site internet permettant la visualisation des matchs ainsi que leur gestion depuis un panel administrateur. Un script de cr\u00e9ation d\u2019une base de donn\u00e9es et insertion de donn\u00e9es a \u00e9t\u00e9 fourni pour la r\u00e9alisation. Ce qui a amen\u00e9 \u00e0 des modifications du sch\u00e9ma conceptuel de base pour qu\u2019il puisse r\u00e9pondre \u00e0 la demande exprim\u00e9e. La demande attendue est de pouvoir g\u00e9n\u00e9rer automatiquement les matchs pour un championnat en fonction du r\u00e9sultat de la pr\u00e9c\u00e9dente saison. Il faut \u00e9galement pouvoir modifier les scores des matchs tout en affectant le classement de la saison.","title":"Documentation Football"},{"location":"#architecture","text":"L'architecture se base sur un serveur Apache et d'une base de donn\u00e9es Postgres.","title":"Architecture"},{"location":"#cas-dutilisation","text":"Ce diagramme pr\u00e9sente les fonctionnalit\u00e9s disponibles sur l'application graph TB intialiseC(intialise un championnat) intialiseR(intialise les rencontres) connection(Se connecter) connectionAdmin(Se connecter en tant qu'admin) commente(commente un article) serveurBdd[(Serveur de base de donn\u00e9es)] Admin:::user --> connectionAdmin classDef user fill:#0acf00; Utilisateur:::user --> connection classDef user fill:#3355ff; connectionAdmin -- <<extend>> --> intialiseC connectionAdmin -- <<extend>> --> intialiseR connection -- <<extends>> --> commente serveurBdd <--> intialise","title":"Cas d'utilisation"},{"location":"#schema-base-de-donnees","text":"","title":"Schema base de donn\u00e9es"},{"location":"pages/admin/","text":"Le Panel administrateur Une fois connect\u00e9, l'administrateur peut acc\u00e9der au panel admin. Cela lui permet \u00e0 l'utilisateur de g\u00e9n\u00e9rer les saisons avec les match attribu\u00e9. Il utilise des fonctions PlpgSQL. G\u00e9n\u00e9rer une nouvelle saison Un nouveau championnat se base sur les r\u00e9sultats du pr\u00e9c\u00e9dent championnat : on s\u00e9lectionne les meilleurs \u00e9quipes en fonction des points gagn\u00e9es. create function generate_saison ( idchamp integer , anneechamp integer ) returns boolean language plpgsql as $$ -- Genere une saison pour un championnat -- Les \u00e9quipes sont selectionnene fonction de celle de la pr\u00e9c\u00e9dente saison -- Auteur : Marcel Lhote DECLARE liste_club integer []; anneeprecedente integer ; res boolean ; BEGIN anneeprecedente : = anneechamp - 1 ; raise notice 'anneprece %' , anneeprecedente ; liste_club : = ARRAY ( SELECT saison . id_club FROM saison WHERE id_championnat = idChamp AND annee = anneeprecedente ORDER BY nb_points DESC limit 20 ); raise notice 'length %' , array_length ( liste_club , 1 ); IF array_length ( liste_club , 1 ) = 20 THEN -- boucle insertion \u00e9quipe dans la saison FOR i in 1 .. array_length ( liste_club , 1 ) LOOP INSERT INTO saison ( id_club , id_championnat , annee ) values ( liste_club [ i ], idchamp , anneechamp ); END LOOP ; res = true ; ELSE res = false ; END IF ; return res ; END ; $$ ; alter function generate_saison ( integer , integer ) owner to postgres ; les rencontres Apr\u00e8s avoir g\u00e9n\u00e9rer la saisons il faut enregistrer les match. Toutes les semaines un match est jou\u00e9 par tout les clubs. On initialise \u00e9galement les matchs retours. create function generate_rencontre ( idchamp integer , datematch date ) returns boolean language plpgsql as $$ -- Genere une les rencontres pour une saison en fonction de l'annee de la date avec la date du premier match, le reste des match est calcul\u00e9 automatiquement -- Auteur : Marcel Lhote DECLARE liste_equipe integer []; liste_arbitre integer []; anneechamp integer ; h integer ; temp integer ; res boolean ; BEGIN anneechamp : = EXTRACT ( YEAR FROM datematch ); liste_equipe : = ARRAY ( SELECT saison . id_club FROM saison WHERE id_championnat = idChamp AND annee = anneechamp ORDER BY nb_points DESC limit 20 ); -- boucle du nombre de jour FOR j in 1 .. array_length ( liste_equipe , 1 ) - 1 LOOP --raise notice 'jour : %', j; --raise notice 'tableau : %',liste_equipe; liste_arbitre : = ARRAY ( SELECT id_arbitre FROM arbitre ORDER BY RANDOM ()); h : = ARRAY_LENGTH ( liste_equipe , 1 ); -- boucle du d'ajout des rencontres avec le tableau des \u00e9quipe FOR i in 1 .. ARRAY_LENGTH ( liste_equipe , 1 ) / 2 LOOP -- raise notice 'match : %', i; -- raise notice 'domicile : %', liste_equipe[i]; -- raise notice 'visiteur : %', liste_equipe[h]; INSERT INTO RENCONTRE values ( liste_equipe [ i ], liste_equipe [ h ], liste_arbitre [ i ], dateMatch , 0 , 0 , false ); -- math retroure \u00e0 lieu apr\u00e8s les 19 match de chaques semaines (19*7 = 133) INSERT INTO RENCONTRE values ( liste_equipe [ h ], liste_equipe [ i ], liste_arbitre [ i ], dateMatch + 133 , 0 , 0 , false ); h : = h - 1 ; END LOOP ; dateMatch : = dateMatch + 7 ; -- refonte du tableau pour changer les matchs de la prochaine journee temp : = liste_equipe [ 2 ]; FOR k in 2 .. array_length ( liste_equipe , 1 ) LOOP IF k = array_length ( liste_equipe , 1 ) THEN liste_equipe [ k ] : = temp ; ELSE liste_equipe [ k ] : = liste_equipe [ k + 1 ]; END IF ; END LOOP ; END LOOP ; res : = true ; return res ; END ; $$ ; alter function generate_rencontre ( integer , date ) owner to postgres ;","title":"Panel admin"},{"location":"pages/admin/#le-panel-administrateur","text":"Une fois connect\u00e9, l'administrateur peut acc\u00e9der au panel admin. Cela lui permet \u00e0 l'utilisateur de g\u00e9n\u00e9rer les saisons avec les match attribu\u00e9. Il utilise des fonctions PlpgSQL.","title":"Le Panel administrateur"},{"location":"pages/admin/#generer-une-nouvelle-saison","text":"Un nouveau championnat se base sur les r\u00e9sultats du pr\u00e9c\u00e9dent championnat : on s\u00e9lectionne les meilleurs \u00e9quipes en fonction des points gagn\u00e9es. create function generate_saison ( idchamp integer , anneechamp integer ) returns boolean language plpgsql as $$ -- Genere une saison pour un championnat -- Les \u00e9quipes sont selectionnene fonction de celle de la pr\u00e9c\u00e9dente saison -- Auteur : Marcel Lhote DECLARE liste_club integer []; anneeprecedente integer ; res boolean ; BEGIN anneeprecedente : = anneechamp - 1 ; raise notice 'anneprece %' , anneeprecedente ; liste_club : = ARRAY ( SELECT saison . id_club FROM saison WHERE id_championnat = idChamp AND annee = anneeprecedente ORDER BY nb_points DESC limit 20 ); raise notice 'length %' , array_length ( liste_club , 1 ); IF array_length ( liste_club , 1 ) = 20 THEN -- boucle insertion \u00e9quipe dans la saison FOR i in 1 .. array_length ( liste_club , 1 ) LOOP INSERT INTO saison ( id_club , id_championnat , annee ) values ( liste_club [ i ], idchamp , anneechamp ); END LOOP ; res = true ; ELSE res = false ; END IF ; return res ; END ; $$ ; alter function generate_saison ( integer , integer ) owner to postgres ;","title":"G\u00e9n\u00e9rer une nouvelle saison"},{"location":"pages/admin/#les-rencontres","text":"Apr\u00e8s avoir g\u00e9n\u00e9rer la saisons il faut enregistrer les match. Toutes les semaines un match est jou\u00e9 par tout les clubs. On initialise \u00e9galement les matchs retours. create function generate_rencontre ( idchamp integer , datematch date ) returns boolean language plpgsql as $$ -- Genere une les rencontres pour une saison en fonction de l'annee de la date avec la date du premier match, le reste des match est calcul\u00e9 automatiquement -- Auteur : Marcel Lhote DECLARE liste_equipe integer []; liste_arbitre integer []; anneechamp integer ; h integer ; temp integer ; res boolean ; BEGIN anneechamp : = EXTRACT ( YEAR FROM datematch ); liste_equipe : = ARRAY ( SELECT saison . id_club FROM saison WHERE id_championnat = idChamp AND annee = anneechamp ORDER BY nb_points DESC limit 20 ); -- boucle du nombre de jour FOR j in 1 .. array_length ( liste_equipe , 1 ) - 1 LOOP --raise notice 'jour : %', j; --raise notice 'tableau : %',liste_equipe; liste_arbitre : = ARRAY ( SELECT id_arbitre FROM arbitre ORDER BY RANDOM ()); h : = ARRAY_LENGTH ( liste_equipe , 1 ); -- boucle du d'ajout des rencontres avec le tableau des \u00e9quipe FOR i in 1 .. ARRAY_LENGTH ( liste_equipe , 1 ) / 2 LOOP -- raise notice 'match : %', i; -- raise notice 'domicile : %', liste_equipe[i]; -- raise notice 'visiteur : %', liste_equipe[h]; INSERT INTO RENCONTRE values ( liste_equipe [ i ], liste_equipe [ h ], liste_arbitre [ i ], dateMatch , 0 , 0 , false ); -- math retroure \u00e0 lieu apr\u00e8s les 19 match de chaques semaines (19*7 = 133) INSERT INTO RENCONTRE values ( liste_equipe [ h ], liste_equipe [ i ], liste_arbitre [ i ], dateMatch + 133 , 0 , 0 , false ); h : = h - 1 ; END LOOP ; dateMatch : = dateMatch + 7 ; -- refonte du tableau pour changer les matchs de la prochaine journee temp : = liste_equipe [ 2 ]; FOR k in 2 .. array_length ( liste_equipe , 1 ) LOOP IF k = array_length ( liste_equipe , 1 ) THEN liste_equipe [ k ] : = temp ; ELSE liste_equipe [ k ] : = liste_equipe [ k + 1 ]; END IF ; END LOOP ; END LOOP ; res : = true ; return res ; END ; $$ ; alter function generate_rencontre ( integer , date ) owner to postgres ;","title":"les rencontres"},{"location":"pages/utilisateur/","text":"Utilisateur Connexion L'utilisateur \u00e0 la possibilit\u00e9 de se cr\u00e9er un compte utilisateur et de se connecter au site internet. Le mot de passe enregistr\u00e9 est chiffr\u00e9 en base de donn\u00e9es et la variable $_SESSION est initialis\u00e9 pour garder ses information de connexion. /** * Connecte l'utilisateur * * @param $email : email de l'utilisateur * @param $password : mdp de l'utilisateur * * @return bool : true si la connexion \u00e0 r\u00e9ussie */ function loginUser($email, $password): bool { $res = false; // Connection data $databaseConnection = getDatabaseConnection(); // Cr\u00e9ation statement $statement = $databaseConnection->prepare(' SELECT password_uti FROM utilisateur WHERE email_uti = :email '); // execute sql with actual values $statement->execute(array( 'email' => trim($email) )); $passwordHash = $statement->fetch(); if ($passwordHash) $res = password_verify($password, $passwordHash['password_uti']); if ($res) { $infoUser = getUserWithEmailAddress($email); createSession($infoUser); } return $res; } Articles l'utilisateur \u00e0 la possibilit\u00e9 d'ajouter des commentaires aux articles \u00e9crit. Affichage du d\u00e9taille de l'article L'application utilise Ajax pour cr\u00e9er des popup int\u00e9ractive avec l'utilisateur et affciher en d\u00e9taille un article et ses commentaires. ```php function showPage(id, titre, text) { $.ajax( { url: chemin + 'php/ajax.php?action=voirArticle', type: 'POST', data: {id_article: id}, }) .done(function (msg) { $.confirm( { useBootstrap: false, backgroundDismiss: true, boxWidth: '60%', title: titre, content: text + msg, buttons: { \"Ajouter un commentaire\": function () { addCom(id, titre, text) }, fermer: function () { } }, }); }); }```","title":"Utilisateur"},{"location":"pages/utilisateur/#utilisateur","text":"","title":"Utilisateur"},{"location":"pages/utilisateur/#connexion","text":"L'utilisateur \u00e0 la possibilit\u00e9 de se cr\u00e9er un compte utilisateur et de se connecter au site internet. Le mot de passe enregistr\u00e9 est chiffr\u00e9 en base de donn\u00e9es et la variable $_SESSION est initialis\u00e9 pour garder ses information de connexion. /** * Connecte l'utilisateur * * @param $email : email de l'utilisateur * @param $password : mdp de l'utilisateur * * @return bool : true si la connexion \u00e0 r\u00e9ussie */ function loginUser($email, $password): bool { $res = false; // Connection data $databaseConnection = getDatabaseConnection(); // Cr\u00e9ation statement $statement = $databaseConnection->prepare(' SELECT password_uti FROM utilisateur WHERE email_uti = :email '); // execute sql with actual values $statement->execute(array( 'email' => trim($email) )); $passwordHash = $statement->fetch(); if ($passwordHash) $res = password_verify($password, $passwordHash['password_uti']); if ($res) { $infoUser = getUserWithEmailAddress($email); createSession($infoUser); } return $res; }","title":"Connexion"},{"location":"pages/utilisateur/#articles","text":"l'utilisateur \u00e0 la possibilit\u00e9 d'ajouter des commentaires aux articles \u00e9crit.","title":"Articles"},{"location":"pages/utilisateur/#affichage-du-detaille-de-larticle","text":"L'application utilise Ajax pour cr\u00e9er des popup int\u00e9ractive avec l'utilisateur et affciher en d\u00e9taille un article et ses commentaires. ```php function showPage(id, titre, text) { $.ajax( { url: chemin + 'php/ajax.php?action=voirArticle', type: 'POST', data: {id_article: id}, }) .done(function (msg) { $.confirm( { useBootstrap: false, backgroundDismiss: true, boxWidth: '60%', title: titre, content: text + msg, buttons: { \"Ajouter un commentaire\": function () { addCom(id, titre, text) }, fermer: function () { } }, }); }); }```","title":"Affichage du d\u00e9taille de l'article"}]}